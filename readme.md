# Шпаргалка по Git

## Создание Git-репозитория

Cоздайте папку first-project и сделайте её Git-репозиторием: перейдите в неё с помощью команды cd и выполните 
```bash
git init
```

 «Разгитить» папку, если что-то пошло не так 
```bash
rm -rf .git
```
- Ключ -r (от англ. recursive — «рекурсивно») позволяет удалять папки вместе с их содержимым; 
- Ключ -f (от англ. force — «заставить») избавит вас от вопросов вроде «Вы точно хотите удалить этот файл? А этот? И этот тоже?». 

 Проверить состояние репозитория: 
```bash
git status

```
 Подготовить файлы к сохранению 
```bash
git add
```

- Ключ, или флаг, --all позволяет подготовить к сохранению все файлы в репозитории. 
- Также можно добавить текущую папку целиком — в этом случае все файлы в ней тоже будут добавлены. Обратиться к текущей папке в Bash позволяет точка (.). 
 
 Если файл изменить после git add, он получает статус modified, для добавление в трек нужно снова выполнить git add. 
 
 
 Сделать коммит можно командой git commit c ключом -m (от англ. message — «сообщение»), который присваивает коммиту сообщение. 

```bash
git commit -m "Описание коммита"
```


 Просмотреть историю коммитов 
```bash
git log
```


## Генерируем SSH-ключ 

```bash
cd ~ # перешли в домашнюю директорию 
ls -la .ssh/ # вывели список созданных ключей 
ssh-keygen -t rsa -b 4096 -C "электронная почта, к которой привязан ваш аккаунт на GitHub"
```

- Для Windows три раза нажать enter: 
```bash
Enter a file in which to save the key (C:\Users<имя_пользователя>.ssh):[Press enter]
Enter passphrase (empty for no passphrase): [Type a passphrase]
Enter same passphrase again: [Type passphrase again]
```
- Для Mac то же самое, но немного иначе. 

```bash
ls -a ~/.ssh 
```

На экране должны появиться два файла — один с расширением .pub, другой — без. Файл в .pub — публичный, им можно делиться с веб-сайтами или коллегами. Файл без расширения .pub — приватный. Ни в коем случае не передавайте его никому! 

Для Windows: 

```bash
# скопировать содержимое ключа в буфер обмена:
clip < ~/.ssh/id_rsa.pub
````
Далее:
 * Перейдите на GitHub и выберите пункт Settings (англ. «настройки») в меню аккаунта. 
 * В меню слева нажмите на пункт SSH and GPG keys. 
 * В открывшейся вкладке выберите New SSH key (англ. «новый SSH-ключ»). 
 * В поле Title (англ. «заголовок») напишите название ключа. Например, Personal key (англ. «личный ключ»). 
 * В поле Key type (англ. «тип ключа») должно быть Authentication Key (англ. «ключ аутентификации»). 
 * В поле Key скопируйте ваш ключ из буфера обмена. 
 * Проверьте правильность ключа с помощью следующей команды. 

```bash
ssh -T git@github.com 
```
 Если это первый раз, когда вы используете Git, чтобы поделиться проектом на GitHub, появится предупреждение. 
 Введите yes, чтобы продолжить. Вы увидите приветствие на экране.

## Подключение удаленного репозитория 
 Откройте консоль, перейдите в каталог локального репозитория и введите команду git remote add. 
 URL вы скопировали со страницы удалённого репозитория. 

```bash
git remote add origin git@github.com:%ИМЯ_АККАУНТА%/first-project.git 
```
 Убедиться, что репозитории связаны

```bash
git remote -v
```
 Отправить изменения на удалённый репозиторий 

```bash
git push
```

- В первый раз эту команду нужно вызвать с флагом -u и параметрами origin (имя удалённого репозитория) и main или master (название текущей ветки). 

```bash
git push -u origin main # Если команда приведёт к ошибке, попробуйте заменить main на master.
```
- В дальнейшем при работе с удалённым репозиторием флаг -u можно опустить и писать просто git push. 


## Хеш — идентификатор коммита

- Git преобразует информацию о коммитах с помощью алгоритма SHA-1 и для каждого из них рассчитывает уникальный идентификатор — хеш.
- Хеш — основной идентификатор коммита и позволяет узнать его автора, дату и содержимое закоммиченных файлов.
- Все хеши, а также таблицу соответствий хеш > информация о коммите Git хранит в папке .git.


## Лог

После вызова git log появляется список коммитов.

```bash
git log
```

Разберём элементы, из которых состоит описание:

- строка из цифр и латинских букв после слова commit — это хеш коммита;
- Author — имя автора и его электронная почта;
- Date — дата и время создания коммита;
- в конце находится сообщение коммита.

Получить сокращённый лог — git log --oneline
```bash
git log --oneline
```


## HEAD — всему голова

При вызове команды git log можно заметить надпись (HEAD -> master) 

Файл HEAD (англ. «голова», «головной») — один из служебных файлов папки .git. Он указывает на коммит, который сделан последним (то есть на самый новый).

Внутри HEAD — ссылка на служебный файл: refs/heads/master (или refs/heads/main в зависимости от названия ветки). Если заглянуть в этот файл, можно увидеть хеш последнего коммита.

Когда вы делаете коммит, Git обновляет refs/heads/master — записывает в него хеш последнего коммита. Получается, что HEAD тоже обновляется, так как ссылается на refs/heads/master.

Многие команды Git принимают в качестве параметра хеш коммита. Если нужно передать последний коммит, то вместо его хеша можно просто написать слово HEAD — Git поймёт, что вы имели в виду последний коммит.


## Статусы файлов в Git

Одна из ключевых задач Git — отслеживать изменения файлов в репозитории. Для этого каждый файл помечается каким-либо статусом.
Статусы untracked/tracked, staged и modified:

- Новые файлы в Git-репозитории помечаются как untracked, то есть неотслеживаемые. Git «видит», что такой файл существует, но не следит за изменениями в нём. У untracked-файла нет предыдущих версий, зафиксированных в коммитах или через команду git add.
- staged (англ. «подготовленный»). После выполнения команды git add файл попадает в staging area (от англ. stage — «сцена», «этап [процесса]» и area — «область»), то есть в список файлов, которые войдут в коммит. В этот момент файл находится в состоянии staged.
- tracked (англ. «отслеживаемый»). Состояние tracked — это противоположность untracked. Оно довольно широкое по смыслу: в него попадают файлы, которые уже были зафиксированы с помощью git commit, а также файлы, которые были добавлены в staging area командой git add. То есть все файлы, в которых Git так или иначе отслеживает изменения.
- modified (англ. «изменённый»). Состояние modified означает, что Git сравнил содержимое файла с последней сохранённой версией и нашёл отличия. Например, файл был закоммичен и после этого изменён.

* Для файлов в состояниях staged и modified обычно не указывают, что они также tracked, потому что это состояние подразумевается. *

#### Про staged и modified

Команда git add добавляет в staging area только текущее содержимое файла. Если вы, например, сделаете git add file.txt, а затем измените file.txt, то новое содержимое файла не будет находиться в staging.
Git сообщит об этом с помощью статуса modified: файл изменён относительно той версии, которая уже в staging. Чтобы добавить в staging последнюю версию, нужно выполнить git add file.txt ещё раз.

#### Типичный жизненный цикл файла в Git
1. Файл только что создали. Git ещё не отслеживает содержимое этого файла. Состояние: untracked.
2.  Файл добавили в staging area с помощью git add. Состояние: staged (+ tracked).
- Возможно, изменили файл ещё раз. Состояния: staged, modified (+ tracked).
- Обратите внимание: staged и modified у одного файла, но у разных его версий.
- Ещё раз выполнили git add. Состояние: staged (+ tracked).
3. Сделали коммит с помощью git commit. Состояние: tracked.
4. Изменили файл. Состояние: modified (+ tracked).
5. Снова добавили в staging area с помощью git add. Состояния: staged (+ tracked).
6. Сделали коммит. Состояния: tracked.
7. Повторили пункты 4?74?7 много-много раз.


## Как читать git status

```bash
git status
```

Какие состояния показывает git status:

Большинство файлов в типичном проекте будут находиться в состоянии tracked (то есть закоммичены и не изменены после коммита). Вы не увидите это состояние в выводе команды git status — иначе она бы каждый раз выводила список вообще всех файлов проекта.
В итоге git status показывает только следующие состояния файлов:
- staged (Changes to be committed в выводе git status);
- modified (Changes not staged for commit);
- untracked (Untracked files).

#### Типичные варианты вывода git status

1. Нет ни staged-, ни modified-, ни untracked-файлов.

- Если ничего не менять после коммита, то в проекте не должно быть ни изменённых файлов

```bash
git status
On branch master
nothing to commit, working tree clean  
```
- Последняя строка nothing to commit, working tree clean буквально переводится как «нечего коммитить, рабочая директория чиста».

2.  Найдены неотслеживаемые файлы.

- Создайте в папке файл fileA.txt. Теперь в репозитории есть новый файл в состоянии untracked. Снова вызовите команду git status. Результат будет таким.

```bash
touch fileA.txt
git status
On branch master
Untracked files: # найдены неотслеживаемые файлы
  (use "git add <file>..." to include in what will be committed)
        fileA.txt

nothing added to commit but untracked files present (use "git add" to track)
````
- Файл fileA.txt отображается в секции неотслеживаемых файлов — Untracked files. Это значит, что он не был добавлен в репозиторий через git add.

- Добавьте fileA.txt в staging area с помощью git add и снова запросите git status.

```bash
git add fileA.txt 
git status
On branch master
Changes to be committed: # новая секция
  (use "git restore --staged <file>..." to unstage)
        new file:   fileA.txt 
```
- Теперь fileA.txt находится в секции Changes to be committed (англ. «изменения, которые попадут в коммит»). Если сейчас выполнить коммит, то в репозитории будет зафиксирована текущая версия этого файла. Закоммитьте его.
```bash
git commit -m 'Добавить файл fileA.txt'
# тут будет вывод комманды commit, он нас не интересует
git status
On branch master
nothing to commit, working tree clean 
```
- Вывод команды git status такой же, какой был после первого коммита: «Директория чиста».

3. Найдены изменения, которые не войдут в коммит

- Теперь откройте файл fileA.txt и добавьте в него несколько слов — например, Это файл A!. Сохраните fileA.txt и вызовите команду git status. Её результат будет такой
```bash
# внесли в fileA.txt правки
# запросили статус
$ git status 
On branch master
Changes not staged for commit: # ещё одна секция
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   fileA.txt 
```
- Файл fileA.txt был изменён, но ещё не добавлен в staging area после этого. Так он оказался в секции Changes not staged for commit (англ. «изменения, которые не подготовлены к коммиту»). Эта секция соответствует статусу modified.
Подготовьте правки к коммиту с помощью git add 
```bash
git add fileA.txt
git status
On branch master
Changes to be committed: # все изменения готовы к коммиту
  (use "git restore --staged <file>..." to unstage)
        modified:   fileA.txt 
```

- Теперь в коммит попадёт уже новая версия файла fileA.txt.

4. Файл добавлен в staging area, но после этого изменён

- Вы добавили файл в staging area, но перед самым коммитом вспомнили важную мелочь. Например, вместо одного восклицательного знака в конце строки Это файл A! нужно поставить три.

- Откройте текстовый редактор и добавьте нужные правки. Теперь можно выполнить коммит, но в любой непонятной ситуации сначала стоит вызвать git status. Он покажет следующее.

```bash
# изменили fileA.txt
$ git status
On branch master
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
          modified:   fileA.txt

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
          modified:   fileA.txt 
```
- Файл попал и в staged (Changes to be committed), и в modified (Changes not staged for commit). В staging area находится версия файла с одним восклицательным знаком, а в Changes not staged for commit — уже изменённая версия, с тремя.
- Чтобы закоммитить самую свежую версию файла, нужно снова выполнить git add перед коммитом.


## Оформление сообщений к коммитам

Правильно описывать коммиты — искусство, к которому стоит приобщиться как можно раньше. Хорошо, когда:

- сообщение коммита легко читается;
- оно информативное;
- все сообщения оформлены в одном стиле.

В выводе команды 
```bash
git log --oneline
```
 умещается максимум 72 первых символа сообщения, поэтому многие правила включают пункт: «Сообщение не должно быть длиннее 72 символов».


#### Стили оформления

1. В корпоративном стиле в начале сообщения обычно указывают Jira-ID, а после — текст сообщения.
```bash
git commit -m "LGS-239: Дополнить список пасхалок новыми числами" 
```
2. Conventional Commits
Conventional Commits предлагает такой формат коммита: <type>: <сообщение>. Первая часть type — это тип изменений. Таких типов достаточно много. Вот два примера:

- feat (сокращение от англ. feature) — для новой функциональности;
- fix (от англ. «исправить», «устранить») — для исправленных ошибок.

```bash
git commit -m "feat: добавить подсчёт суммы заказов за неделю" 
```
3. GitHub-стиль

GitHub можно использовать не только для хранения файлов проекта, но и для ведения списка задач (англ. issue) этого проекта. Если коммит «закрывает» или «решает» какую-то задачу, то в его сообщении удобно указывать ссылку на неё. Для этого в любом месте сообщения нужно указать #<номер задачи>. Например, вот так.
```bash
git commit -m "Исправить #334, добавить график температуры"
```
Для сообщений на русском языке часто рекомендуют использовать инфинитивы. Например: Добавить тесты для PipkaService, Исправить ошибку #123 и так далее.
Для сообщений на английском рекомендуется использовать повелительное наклонение (англ. imperative). Например: Use library mega_lib_300, Fix exit button и так далее.










